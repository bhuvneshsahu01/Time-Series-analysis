# -*- coding: utf-8 -*-
"""AirPassengers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bOKSeg5LY3AieaGxwB-3Hena0dzrFMYP
"""

#!/usr/bin/env python
# coding: utf-8

# In[1]:


import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns


# In[2]:


sns.get_dataset_names()


# In[3]:


df = sns.load_dataset('flights')
df['yearMonth'] = pd.to_datetime("01-"+df['month'].astype(str)+"-"+df['year'].astype(str))
df.set_index('yearMonth',inplace=True)
df.head()


# In[4]:


plt.figure(figsize=(10,5))
sns.lineplot(data=df,x=df.index,y=df.passengers)


# In[5]:


df['rollMean']  = df.passengers.rolling(window=12).mean()
df['rollStd']  = df.passengers.rolling(window=12).std()


# In[6]:


plt.figure(figsize=(10,5))
sns.lineplot(data=df,x=df.index,y=df.passengers)
sns.lineplot(data=df,x=df.index,y=df.rollMean)
sns.lineplot(data=df,x=df.index,y=df.rollStd)


# In[7]:


from statsmodels.tsa.stattools import adfuller


# In[8]:


adfTest = adfuller(df['passengers'],autolag='AIC',)


# In[9]:


adfTest


# In[10]:


stats = pd.Series(adfTest[0:4],index=['Test Statistic','p-value','#lags used','number of observations used'])
stats


# In[11]:


for key, values in adfTest[4].items():
    print('criticality',key,":",values)


# In[12]:


def test_stationarity(dataFrame, var):
    dataFrame['rollMean']  = dataFrame[var].rolling(window=12).mean()
    dataFrame['rollStd']  = dataFrame[var].rolling(window=12).std()

    from statsmodels.tsa.stattools import adfuller
    adfTest = adfuller(dataFrame[var],autolag='AIC')
    stats = pd.Series(adfTest[0:4],index=['Test Statistic','p-value','#lags used','number of observations used'])
    print(stats)

    for key, values in adfTest[4].items():
        print('criticality',key,":",values)

    sns.lineplot(data=dataFrame,x=dataFrame.index,y=var)
    sns.lineplot(data=dataFrame,x=dataFrame.index,y='rollMean')
    sns.lineplot(data=dataFrame,x=dataFrame.index,y='rollStd')


# In[13]:


air_df = df[['passengers']]
air_df.head()


# In[14]:


# time shift

air_df['shift'] = air_df.passengers.shift()
air_df['shiftDiff'] = air_df['passengers'] - air_df['shift']
air_df.head()


# In[15]:


test_stationarity(air_df.dropna(),'shiftDiff')


# In[16]:


log_df = df[['passengers']]
log_df['log'] = np.log(log_df['passengers'])
log_df.head()


# In[17]:


test_stationarity(log_df,'log')


# In[18]:


sqrt_df = df[['passengers']]
sqrt_df['sqrt'] = np.sqrt(df['passengers'])
sqrt_df.head()


# In[19]:


test_stationarity(sqrt_df,'sqrt')


# In[20]:


cbrt_df = df[['passengers']]
cbrt_df['cbrt'] = np.cbrt(cbrt_df['passengers'])
cbrt_df.head()


# In[21]:


test_stationarity(cbrt_df,'cbrt')


# In[22]:


log_df2 = log_df[['passengers','log']]
log_df2['log_sqrt'] = np.sqrt(log_df['log'])
log_df2['logShiftDiff'] = log_df2['log_sqrt'] - log_df2['log_sqrt'].shift()
log_df2.head()


# In[23]:


test_stationarity(log_df2.dropna(),'logShiftDiff')


# In[24]:


log_shift = df[['passengers']].copy(deep=True)
log_shift['log'] = np.log(log_shift['passengers'])
log_shift['logShift'] = log_shift['log'].shift()
log_shift['logShiftDiff'] = log_shift['log'] - log_shift['logShift']
log_shift.head()


# In[25]:


test_stationarity(log_shift.dropna(),'logShiftDiff')


# # Next - 2

# In[80]:


airP = df[['passengers']].copy(deep=True)
airP['firstDiff'] = airP['passengers'].diff()
airP['Diff12'] = airP['passengers'].diff(12)


# In[81]:


airP.head()


# In[84]:

from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf


# In[86]:


plot_pacf(airP['firstDiff'].dropna(),lags=20);


# In[87]:


plot_acf(airP['firstDiff'].dropna(),lags=20);


# In[88]:


# p = 1, q = 3, d =1


# In[94]:


train = airP[:round(len(airP)*70/100)]
test = airP[round(len(airP)*70/100):]
test.head()


# In[100]:


model = ARIMA(train['passengers'],order=(1,1,3))
model_fit = model.fit()
prediction = model_fit.predict(start=test.index[0],end=test.index[-1])
airP['arimaPred'] = prediction
airP.tail()


# In[121]:


airP.dropna()
sns.lineplot(data=airP,x=airP.index,y='passengers')
sns.lineplot(data=airP,x=airP.index,y='arimaPred')


# In[122]:


from sklearn.metrics import mean_squared_error


# In[124]:


np.sqrt(mean_squared_error(test['passengers'],prediction))


# In[126]:


from statsmodels.tsa.statespace.sarimax import SARIMAX


# In[141]:


plot_pacf(airP['Diff12'].dropna(),lags=20);
plot_acf(airP['Diff12'].dropna(),lags=20);


# In[147]:


model = SARIMAX(train['passengers'],order=(1,1,3),seasonal_order=(2,1,2,12))
model_fit = model.fit()
prediction = model_fit.predict(start=test.index[0],end=test.index[-1])
airP['sarimaxPred'] = prediction


# In[196]:


airP.dropna()
sns.lineplot(data=airP,x=airP.index,y='passengers')
sns.lineplot(data=airP,x=airP.index,y='sarimaxPred')
sns.lineplot(data=airP,x=airP.index,y='arimaPred')
# model_fit.predict(start=futureDate.index[0],end=futureDate.index[-1]).plot(color='black')


# In[144]:


np.sqrt(mean_squared_error(test['passengers'],prediction))


# In[188]:


futureDate = pd.DataFrame(pd.date_range(start='1961-01-01', end='1962-12-01',freq='MS'),columns=['Dates'])
futureDate.set_index('Dates',inplace=True)
futureDate.head()


# In[192]:


model_fit.predict(start=futureDate.index[0],end=futureDate.index[-1])


# In[195]:


airP.dropna()
sns.lineplot(data=airP,x=airP.index,y='passengers')
sns.lineplot(data=airP,x=airP.index,y='sarimaxPred')
sns.lineplot(data=airP,x=airP.index,y='arimaPred')
model_fit.predict(start=futureDate.index[0],end=futureDate.index[-1]).plot(color='black')


# # Next - 3

# In[201]:


checkDf = df[['passengers']]
checkDf['diff1'] = checkDf.diff()
# checkDf['diffInv'] = checkDf['diff1'].diffinv()
checkDf.head()

from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Scaling the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(airP[['passengers']])

# Creating sequences for LSTM (use previous 12 months to predict the next month)
sequence_length = 12
X_train, y_train = [], []
for i in range(sequence_length, len(train)):
    X_train.append(scaled_data[i-sequence_length:i, 0])
    y_train.append(scaled_data[i, 0])

X_train, y_train = np.array(X_train), np.array(y_train)
X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

# Prepare the test data similarly
X_test, y_test = [], []
for i in range(sequence_length, len(test)):
    X_test.append(scaled_data[len(train) + i-sequence_length:len(train) + i, 0])
    y_test.append(scaled_data[len(train) + i, 0])

X_test, y_test = np.array(X_test), np.array(y_test)
X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

# Define the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
model.add(LSTM(50, return_sequences=False))
model.add(Dense(25))
model.add(Dense(1))

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, batch_size=1, epochs=5)

# Predict and inverse scale the predictions
predictions = model.predict(X_test)
predictions = scaler.inverse_transform(predictions)

# Calculate RMSE
from sklearn.metrics import mean_squared_error
rmse = np.sqrt(mean_squared_error(y_test, predictions))
print(f'RMSE: {rmse}')

from prophet import Prophet

# Prepare the data
prophet_df = airP.reset_index()[['yearMonth', 'passengers']]
prophet_df.columns = ['ds', 'y']

# Split into train and test
train_size = int(0.7 * len(prophet_df))
prophet_train = prophet_df[:train_size]
prophet_test = prophet_df[train_size:]

# Define and fit the Prophet model
model = Prophet(yearly_seasonality=True, weekly_seasonality=False, daily_seasonality=False)
model.fit(prophet_train)

# Forecasting future values
future = model.make_future_dataframe(periods=len(prophet_test), freq='MS')
forecast = model.predict(future)

# Visualize the forecast
model.plot(forecast)
plt.show()

# Calculate RMSE on the test data
predicted_values = forecast[-len(prophet_test):]['yhat'].values
rmse = np.sqrt(mean_squared_error(prophet_test['y'], predicted_values))
print(f'RMSE: {rmse}')

from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from prophet import Prophet
from sklearn.preprocessing import MinMaxScaler

def run_all_models(train, test, sequence_length=12):
    results = {}
    predictions_dict = {}

    # ARIMA Model
    arima_model = ARIMA(train['passengers'], order=(1,1,3))
    arima_model_fit = arima_model.fit()
    arima_pred = arima_model_fit.predict(start=test.index[0], end=test.index[-1])
    arima_rmse = np.sqrt(mean_squared_error(test['passengers'], arima_pred))
    results['ARIMA'] = arima_rmse
    predictions_dict['ARIMA'] = arima_pred

    # SARIMAX Model
    sarimax_model = SARIMAX(train['passengers'], order=(1,1,3), seasonal_order=(2,1,2,12))
    sarimax_model_fit = sarimax_model.fit()
    sarimax_pred = sarimax_model_fit.predict(start=test.index[0], end=test.index[-1])
    sarimax_rmse = np.sqrt(mean_squared_error(test['passengers'], sarimax_pred))
    results['SARIMAX'] = sarimax_rmse
    predictions_dict['SARIMAX'] = sarimax_pred

    # LSTM Model
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(train[['passengers']])
    X_train, y_train = [], []
    for i in range(sequence_length, len(scaled_data)):
        X_train.append(scaled_data[i-sequence_length:i, 0])
        y_train.append(scaled_data[i, 0])
    X_train, y_train = np.array(X_train), np.array(y_train)
    X_train = np.reshape(X_train, (X_train.shape[0], X_train.shape[1], 1))

    lstm_model = Sequential()
    lstm_model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
    lstm_model.add(LSTM(50, return_sequences=False))
    lstm_model.add(Dense(25))
    lstm_model.add(Dense(1))
    lstm_model.compile(optimizer='adam', loss='mean_squared_error')
    lstm_model.fit(X_train, y_train, batch_size=1, epochs=5, verbose=0)

    scaled_test = scaler.transform(test[['passengers']])
    X_test = []
    for i in range(sequence_length, len(scaled_test)):
        X_test.append(scaled_test[i-sequence_length:i, 0])
    X_test = np.array(X_test)
    X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

    lstm_pred = lstm_model.predict(X_test)
    lstm_pred = scaler.inverse_transform(lstm_pred)
    lstm_pred = lstm_pred.flatten()  # Flatten to ensure compatibility
    lstm_rmse = np.sqrt(mean_squared_error(test['passengers'][sequence_length:], lstm_pred))
    results['LSTM'] = lstm_rmse
    predictions_dict['LSTM'] = pd.Series(lstm_pred, index=test.index[sequence_length:])

    # Prophet Model
    prophet_df = train.reset_index()[['yearMonth', 'passengers']]
    prophet_df.columns = ['ds', 'y']
    prophet_model = Prophet(yearly_seasonality=True, weekly_seasonality=False, daily_seasonality=False)
    prophet_model.fit(prophet_df)
    future = prophet_model.make_future_dataframe(periods=len(test), freq='MS')
    forecast = prophet_model.predict(future)
    prophet_pred = forecast['yhat'][-len(test):].values
    prophet_rmse = np.sqrt(mean_squared_error(test['passengers'], prophet_pred))
    results['Prophet'] = prophet_rmse
    predictions_dict['Prophet'] = pd.Series(prophet_pred, index=test.index)

    # Plot Forecasts
    plt.figure(figsize=(14, 8))
    plt.plot(test.index, test['passengers'], label='Actual', color='black')
    for model_name, prediction in predictions_dict.items():
        plt.plot(prediction.index, prediction, label=model_name)
    plt.title('Model Forecast Comparison')
    plt.xlabel('Date')
    plt.ylabel('Number of Passengers')
    plt.legend()
    plt.show()

    # Display RMSE Results
    print("Root Mean Square Error (RMSE) for each model:")
    for model_name, rmse in results.items():
        print(f"{model_name}: {rmse:.2f}")

    return results

# Run the function
results = run_all_models(train, test)

